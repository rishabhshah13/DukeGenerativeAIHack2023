{"ast":null,"code":"'use strict';\n\n/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nfunction memcmp(buf1, pos1, buf2, pos2, num) {\n  for (let i = 0; i < num; ++i) {\n    if (buf1[pos1 + i] !== buf2[pos2 + i]) return false;\n  }\n  return true;\n}\nclass SBMH {\n  constructor(needle, cb) {\n    if (typeof cb !== 'function') throw new Error('Missing match callback');\n    if (typeof needle === 'string') needle = Buffer.from(needle);else if (!Buffer.isBuffer(needle)) throw new Error(`Expected Buffer for needle, got ${typeof needle}`);\n    const needleLen = needle.length;\n    this.maxMatches = Infinity;\n    this.matches = 0;\n    this._cb = cb;\n    this._lookbehindSize = 0;\n    this._needle = needle;\n    this._bufPos = 0;\n    this._lookbehind = Buffer.allocUnsafe(needleLen);\n\n    // Initialize occurrence table.\n    this._occ = [needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen];\n\n    // Populate occurrence table with analysis of the needle, ignoring the last\n    // letter.\n    if (needleLen > 1) {\n      for (let i = 0; i < needleLen - 1; ++i) this._occ[needle[i]] = needleLen - 1 - i;\n    }\n  }\n  reset() {\n    this.matches = 0;\n    this._lookbehindSize = 0;\n    this._bufPos = 0;\n  }\n  push(chunk, pos) {\n    let result;\n    if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, 'latin1');\n    const chunkLen = chunk.length;\n    this._bufPos = pos || 0;\n    while (result !== chunkLen && this.matches < this.maxMatches) result = feed(this, chunk);\n    return result;\n  }\n  destroy() {\n    const lbSize = this._lookbehindSize;\n    if (lbSize) this._cb(false, this._lookbehind, 0, lbSize, false);\n    this.reset();\n  }\n}\nfunction feed(self, data) {\n  const len = data.length;\n  const needle = self._needle;\n  const needleLen = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehindSize - 2]\n  let pos = -self._lookbehindSize;\n  const lastNeedleCharPos = needleLen - 1;\n  const lastNeedleChar = needle[lastNeedleCharPos];\n  const end = len - needleLen;\n  const occ = self._occ;\n  const lookbehind = self._lookbehind;\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= end) {\n      const nextPos = pos + lastNeedleCharPos;\n      const ch = nextPos < 0 ? lookbehind[self._lookbehindSize + nextPos] : data[nextPos];\n      if (ch === lastNeedleChar && matchNeedle(self, data, pos, lastNeedleCharPos)) {\n        self._lookbehindSize = 0;\n        ++self.matches;\n        if (pos > -self._lookbehindSize) self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);else self._cb(true, undefined, 0, 0, true);\n        return self._bufPos = pos + needleLen;\n      }\n      pos += occ[ch];\n    }\n\n    // No match.\n\n    // There's too few data for Boyer-Moore-Horspool to run,\n    // so let's use a different algorithm to skip as much as\n    // we can.\n    // Forward pos until\n    //   the trailing part of lookbehind + data\n    //   looks like the beginning of the needle\n    // or until\n    //   pos == 0\n    while (pos < 0 && !matchNeedle(self, data, pos, len - pos)) ++pos;\n    if (pos < 0) {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      const bytesToCutOff = self._lookbehindSize + pos;\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        self._cb(false, lookbehind, 0, bytesToCutOff, false);\n      }\n      self._lookbehindSize -= bytesToCutOff;\n      lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);\n      lookbehind.set(data, self._lookbehindSize);\n      self._lookbehindSize += len;\n      self._bufPos = len;\n      return len;\n    }\n\n    // Discard lookbehind buffer.\n    self._cb(false, lookbehind, 0, self._lookbehindSize, false);\n    self._lookbehindSize = 0;\n  }\n  pos += self._bufPos;\n  const firstNeedleChar = needle[0];\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= end) {\n    const ch = data[pos + lastNeedleCharPos];\n    if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {\n      ++self.matches;\n      if (pos > 0) self._cb(true, data, self._bufPos, pos, true);else self._cb(true, undefined, 0, 0, true);\n      return self._bufPos = pos + needleLen;\n    }\n    pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  while (pos < len) {\n    if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {\n      ++pos;\n      continue;\n    }\n    data.copy(lookbehind, 0, pos, len);\n    self._lookbehindSize = len - pos;\n    break;\n  }\n\n  // Everything until `pos` is guaranteed not to contain needle data.\n  if (pos > 0) self._cb(false, data, self._bufPos, pos < len ? pos : len, true);\n  self._bufPos = len;\n  return len;\n}\nfunction matchNeedle(self, data, pos, len) {\n  const lb = self._lookbehind;\n  const lbSize = self._lookbehindSize;\n  const needle = self._needle;\n  for (let i = 0; i < len; ++i, ++pos) {\n    const ch = pos < 0 ? lb[lbSize + pos] : data[pos];\n    if (ch !== needle[i]) return false;\n  }\n  return true;\n}\nmodule.exports = SBMH;","map":{"version":3,"names":["memcmp","buf1","pos1","buf2","pos2","num","i","SBMH","constructor","needle","cb","Error","Buffer","from","isBuffer","needleLen","length","maxMatches","Infinity","matches","_cb","_lookbehindSize","_needle","_bufPos","_lookbehind","allocUnsafe","_occ","reset","push","chunk","pos","result","chunkLen","feed","destroy","lbSize","self","data","len","lastNeedleCharPos","lastNeedleChar","end","occ","lookbehind","nextPos","ch","matchNeedle","undefined","bytesToCutOff","copy","set","firstNeedleChar","lb","module","exports"],"sources":["/Users/rishabhshah/Desktop/GenAIGit/DukeGenAI2023/adhd-fe/node_modules/streamsearch/lib/sbmh.js"],"sourcesContent":["'use strict';\n/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nfunction memcmp(buf1, pos1, buf2, pos2, num) {\n  for (let i = 0; i < num; ++i) {\n    if (buf1[pos1 + i] !== buf2[pos2 + i])\n      return false;\n  }\n  return true;\n}\n\nclass SBMH {\n  constructor(needle, cb) {\n    if (typeof cb !== 'function')\n      throw new Error('Missing match callback');\n\n    if (typeof needle === 'string')\n      needle = Buffer.from(needle);\n    else if (!Buffer.isBuffer(needle))\n      throw new Error(`Expected Buffer for needle, got ${typeof needle}`);\n\n    const needleLen = needle.length;\n\n    this.maxMatches = Infinity;\n    this.matches = 0;\n\n    this._cb = cb;\n    this._lookbehindSize = 0;\n    this._needle = needle;\n    this._bufPos = 0;\n\n    this._lookbehind = Buffer.allocUnsafe(needleLen);\n\n    // Initialize occurrence table.\n    this._occ = [\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen\n    ];\n\n    // Populate occurrence table with analysis of the needle, ignoring the last\n    // letter.\n    if (needleLen > 1) {\n      for (let i = 0; i < needleLen - 1; ++i)\n        this._occ[needle[i]] = needleLen - 1 - i;\n    }\n  }\n\n  reset() {\n    this.matches = 0;\n    this._lookbehindSize = 0;\n    this._bufPos = 0;\n  }\n\n  push(chunk, pos) {\n    let result;\n    if (!Buffer.isBuffer(chunk))\n      chunk = Buffer.from(chunk, 'latin1');\n    const chunkLen = chunk.length;\n    this._bufPos = pos || 0;\n    while (result !== chunkLen && this.matches < this.maxMatches)\n      result = feed(this, chunk);\n    return result;\n  }\n\n  destroy() {\n    const lbSize = this._lookbehindSize;\n    if (lbSize)\n      this._cb(false, this._lookbehind, 0, lbSize, false);\n    this.reset();\n  }\n}\n\nfunction feed(self, data) {\n  const len = data.length;\n  const needle = self._needle;\n  const needleLen = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehindSize - 2]\n  let pos = -self._lookbehindSize;\n  const lastNeedleCharPos = needleLen - 1;\n  const lastNeedleChar = needle[lastNeedleCharPos];\n  const end = len - needleLen;\n  const occ = self._occ;\n  const lookbehind = self._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= end) {\n      const nextPos = pos + lastNeedleCharPos;\n      const ch = (nextPos < 0\n                  ? lookbehind[self._lookbehindSize + nextPos]\n                  : data[nextPos]);\n\n      if (ch === lastNeedleChar\n          && matchNeedle(self, data, pos, lastNeedleCharPos)) {\n        self._lookbehindSize = 0;\n        ++self.matches;\n        if (pos > -self._lookbehindSize)\n          self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);\n        else\n          self._cb(true, undefined, 0, 0, true);\n\n        return (self._bufPos = pos + needleLen);\n      }\n\n      pos += occ[ch];\n    }\n\n    // No match.\n\n    // There's too few data for Boyer-Moore-Horspool to run,\n    // so let's use a different algorithm to skip as much as\n    // we can.\n    // Forward pos until\n    //   the trailing part of lookbehind + data\n    //   looks like the beginning of the needle\n    // or until\n    //   pos == 0\n    while (pos < 0 && !matchNeedle(self, data, pos, len - pos))\n      ++pos;\n\n    if (pos < 0) {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      const bytesToCutOff = self._lookbehindSize + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        self._cb(false, lookbehind, 0, bytesToCutOff, false);\n      }\n\n      self._lookbehindSize -= bytesToCutOff;\n      lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);\n      lookbehind.set(data, self._lookbehindSize);\n      self._lookbehindSize += len;\n\n      self._bufPos = len;\n      return len;\n    }\n\n    // Discard lookbehind buffer.\n    self._cb(false, lookbehind, 0, self._lookbehindSize, false);\n    self._lookbehindSize = 0;\n  }\n\n  pos += self._bufPos;\n\n  const firstNeedleChar = needle[0];\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= end) {\n    const ch = data[pos + lastNeedleCharPos];\n\n    if (ch === lastNeedleChar\n        && data[pos] === firstNeedleChar\n        && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {\n      ++self.matches;\n      if (pos > 0)\n        self._cb(true, data, self._bufPos, pos, true);\n      else\n        self._cb(true, undefined, 0, 0, true);\n\n      return (self._bufPos = pos + needleLen);\n    }\n\n    pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  while (pos < len) {\n    if (data[pos] !== firstNeedleChar\n        || !memcmp(data, pos, needle, 0, len - pos)) {\n      ++pos;\n      continue;\n    }\n    data.copy(lookbehind, 0, pos, len);\n    self._lookbehindSize = len - pos;\n    break;\n  }\n\n  // Everything until `pos` is guaranteed not to contain needle data.\n  if (pos > 0)\n    self._cb(false, data, self._bufPos, pos < len ? pos : len, true);\n\n  self._bufPos = len;\n  return len;\n}\n\nfunction matchNeedle(self, data, pos, len) {\n  const lb = self._lookbehind;\n  const lbSize = self._lookbehindSize;\n  const needle = self._needle;\n\n  for (let i = 0; i < len; ++i, ++pos) {\n    const ch = (pos < 0 ? lb[lbSize + pos] : data[pos]);\n    if (ch !== needle[i])\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA,SAASA,MAAMA,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,GAAG,EAAE;EAC3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,EAAE,EAAEC,CAAC,EAAE;IAC5B,IAAIL,IAAI,CAACC,IAAI,GAAGI,CAAC,CAAC,KAAKH,IAAI,CAACC,IAAI,GAAGE,CAAC,CAAC,EACnC,OAAO,KAAK;EAChB;EACA,OAAO,IAAI;AACb;AAEA,MAAMC,IAAI,CAAC;EACTC,WAAWA,CAACC,MAAM,EAAEC,EAAE,EAAE;IACtB,IAAI,OAAOA,EAAE,KAAK,UAAU,EAC1B,MAAM,IAAIC,KAAK,CAAC,wBAAwB,CAAC;IAE3C,IAAI,OAAOF,MAAM,KAAK,QAAQ,EAC5BA,MAAM,GAAGG,MAAM,CAACC,IAAI,CAACJ,MAAM,CAAC,CAAC,KAC1B,IAAI,CAACG,MAAM,CAACE,QAAQ,CAACL,MAAM,CAAC,EAC/B,MAAM,IAAIE,KAAK,CAAE,mCAAkC,OAAOF,MAAO,EAAC,CAAC;IAErE,MAAMM,SAAS,GAAGN,MAAM,CAACO,MAAM;IAE/B,IAAI,CAACC,UAAU,GAAGC,QAAQ;IAC1B,IAAI,CAACC,OAAO,GAAG,CAAC;IAEhB,IAAI,CAACC,GAAG,GAAGV,EAAE;IACb,IAAI,CAACW,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,OAAO,GAAGb,MAAM;IACrB,IAAI,CAACc,OAAO,GAAG,CAAC;IAEhB,IAAI,CAACC,WAAW,GAAGZ,MAAM,CAACa,WAAW,CAACV,SAAS,CAAC;;IAEhD;IACA,IAAI,CAACW,IAAI,GAAG,CACVX,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAChEA,SAAS,EAAEA,SAAS,EAAEA,SAAS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"},"metadata":{},"sourceType":"script","externalDependencies":[]}